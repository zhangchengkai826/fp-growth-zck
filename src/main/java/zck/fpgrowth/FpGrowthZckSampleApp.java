/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package zck.fpgrowth;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Iterator;

public class FpGrowthZckSampleApp {
    private static class ItemSet{
        public ItemSet(Integer supCnt) {
            this.supCnt = supCnt;
        }
        public ArrayList<String> items = new ArrayList<String>();
        public Integer supCnt;
        public String getItemsRepr() {
            StringBuilder sb = new StringBuilder();
            sb.append("{");
            for(int i = 0; i < items.size(); i++) {
                sb.append(items.get(i));
                if(i != items.size()-1) {
                    sb.append(", ");
                }
            }
            sb.append("}");
            return sb.toString();
        }
    }
    private static ArrayList<ItemSet> selfJoin(ArrayList<ItemSet> x){
        ArrayList<ItemSet> result = new ArrayList<ItemSet>();
        for(int i = 0; i < x.size(); i++) {
            ItemSet a = x.get(i);
            for(int j = i+1; j < x.size(); j++) {
                ItemSet b = x.get(j);
                boolean ok = true;
                // a.items & b.items are ordered. (this can be proved by induction)
                for(int k = 0; k < a.items.size()-1; k++) {
                    if(a.items.get(k) != b.items.get(k)) {
                        ok = false;
                        break;
                    }
                }
                if(ok) {
                    // itemset support count cannot be determined yet.
                    ItemSet newItemSet = new ItemSet(0);
                    for(int k = 0; k < a.items.size(); k++) {
                        newItemSet.items.add(a.items.get(k));
                    }
                    newItemSet.items.add(b.items.get(b.items.size()-1));
                    result.add(newItemSet);
                }
            }
        }
        return result;
    }
    private static ArrayList<ItemSet> prune(ArrayList<ItemSet> C1, ArrayList<ItemSet> C) {
        ArrayList<ItemSet> result = new ArrayList<ItemSet>();
        for(ItemSet s : C1) {
            boolean ok = true;
            for(int ms = 0; ms < s.items.size(); ms++) {
                int c1j = 0, ci = 0, cj = 0;
                if(ms == c1j) {
                    ms++;
                }
                while(true) {
                    if(cj >= C.get(ci).items.size()) {
                        // find an itemset in C
                        break;
                    }
                    if(ci >= C.size()) {
                        // cannot find an itemset in C
                        ok = false;
                        break;
                    }
                    int comp = s.items.get(c1j).compareTo(C.get(ci).items.get(cj));
                    if(comp == 0) {
                        // test next item
                        c1j++; cj++;
                        continue;
                    } else if(comp < 0) {
                        // cannot find an itemset in C
                        ok = false;
                        break;
                    } else {
                        // test next itemset
                        ci++;
                        continue;
                    }
                }
                if(!ok) {
                    // cannot find an itemset in C corresponding to {itemset s in C1 dropping item at position *ms*}
                    break;
                }
            }
            if(ok) {
                // find an itemset in C corresponding to {itemset s in C1 dropping item at position *ms*}
                result.add(s);
            }
        }
        return result;
    }
    private static class TreeNode {
        public TreeNode parent;
        public ArrayList<TreeNode> children = new ArrayList<>();
        public String item;
        public int count;
        public TreeNode next;
    }
    private static class CondPatternItemSet extends ItemSet {
        public CondPatternItemSet(Integer supCnt) {
            super(supCnt);
        }
        public int subTreeId;
    }
    private static boolean fpGrowth(String dataFilePath, int minSupCnt, double minConfThr) {
        BufferedReader br;
        ArrayList<ItemSet> C = new ArrayList<ItemSet>();
        ArrayList<ItemSet> freqItemSets = new ArrayList<ItemSet>();
        ArrayList<ArrayList<String>> dataCache = new ArrayList<>();
        ArrayList<String> itemsCache = new ArrayList<>();
        ArrayList<ItemSet> CSupDesc;
        try{
            br = new BufferedReader(new FileReader(dataFilePath));
            String line;
            br.readLine();
            HashMap<String, Integer> m = new HashMap<String, Integer>();
            while((line = br.readLine()) != null) {
                String[] tokens = line.split(" |, ");
                ArrayList<String> dataRow = new ArrayList<>();
                for(int i = 1; i < tokens.length; i++) {
                    if(m.get(tokens[i]) == null) {
                        m.put(tokens[i], 1);
                    } else {
                        m.put(tokens[i], m.get(tokens[i])+1);
                    }
                    dataRow.add(tokens[i]);
                }
                dataRow.sort(new Comparator<String>() {
                    @Override
                    public int compare(String o1, String o2) {
                        return o1.compareTo(o2);
                    }
                });
                dataCache.add(dataRow);
            }
            Iterator<String> it = m.keySet().iterator();
            while(it.hasNext()){
                String k = it.next();
                Integer v = m.get(k);
                itemsCache.add(k);
                if(v >= minSupCnt) {
                    ItemSet s = new ItemSet(v);
                    s.items.add(k);
                    C.add(s);
                }
            }
            // this makes sure that for any ItemSet, its items property is always ordered.
            C.sort(new Comparator<ItemSet>() {
                @Override
                public int compare(ItemSet o1, ItemSet o2) {
                    return o1.items.get(0).compareTo(o2.items.get(0));
                }
            });
            itemsCache.sort(new Comparator<String>() {
                @Override
                public int compare(String o1, String o2) {
                    return o1.compareTo(o2);
                }
            });
            CSupDesc = (ArrayList<ItemSet>)C.clone();
            CSupDesc.sort(new Comparator<ItemSet>() {
                @Override
                public int compare(ItemSet o1, ItemSet o2) {
                    return o2.supCnt - o1.supCnt;
                }
            });
            br.close();
        } catch(FileNotFoundException e) {
            e.printStackTrace();
            return false;
        } catch(IOException e){
            e.printStackTrace();
            return false;
        }

        // build the tree
        TreeNode root = new TreeNode();
        TreeNode[] lklist = new TreeNode[itemsCache.size()];
        for(int i = 0; i < lklist.length; i++) {
            lklist[i] = null;
        }
        for(ArrayList<String> row : dataCache) {
            ArrayList<ItemSet> t = new ArrayList<>();
            for(String itm : row) {
                int supCnt = 0;
                for(ItemSet s : CSupDesc) {
                    if(s.items.get(0) == itm) {
                        supCnt = s.supCnt;
                        break;
                    }
                }
                if(supCnt > 0) {
                    ItemSet s = new ItemSet(supCnt);
                    s.items.add(itm);
                    t.add(s);
                }
            }
            t.sort(new Comparator<ItemSet>() {
                @Override
                public int compare(ItemSet o1, ItemSet o2) {
                    return o2.supCnt - o1.supCnt;
                }
            });
            TreeNode node = root;
            for(ItemSet s : t) {
                if(node.children.stream().filter(o -> o.item == s.items.get(0)).findFirst().isPresent()) {
                    node.children.stream().filter(o -> o.item == s.items.get(0)).findFirst().get().count++;
                } else {
                    TreeNode newNode = new TreeNode();
                    newNode.parent = node;
                    newNode.item = s.items.get(0);
                    newNode.count = 1;
                    newNode.next = lklist[itemsCache.indexOf(newNode.item)];
                    lklist[itemsCache.indexOf(newNode.item)] = newNode;
                    node.children.add(newNode);
                }
                node = node.children.stream().filter(o -> o.item == s.items.get(0)).findFirst().get();
            }
        }

        for(int i = CSupDesc.size()-1; i >= 0; i--) {
            if(CSupDesc.get(i).supCnt >= minSupCnt) {
                freqItemSets.add(CSupDesc.get(i));
            }
            String itm = CSupDesc.get(i).items.get(0);
            TreeNode node = lklist[itemsCache.indexOf(itm)];
            
            // calculate conditional pattern base
            ArrayList<CondPatternItemSet> condPatternBase = new ArrayList<>();
            while(node != null) {
                TreeNode p = node.parent;
                if(p != root) {
                    CondPatternItemSet s = new CondPatternItemSet(node.count);
                    while(true) {  
                        s.items.add(p.item);
                        if(p.parent == root) {
                            s.subTreeId = itemsCache.indexOf(p.item);
                            break;
                        }
                        p = p.parent;
                    }
                    condPatternBase.add(s);
                }
                node = node.next;
            }

            // build conditional FP-tree
            HashMap<Integer, HashMap<String, Integer>> condFpTree = new HashMap<>();
            for(CondPatternItemSet s : condPatternBase) {
                for(String itm1 : s.items) {
                    if(!condFpTree.containsKey(s.subTreeId)) {
                        condFpTree.put(s.subTreeId, new HashMap<>());
                    }
                    if(!condFpTree.get(s.subTreeId).containsKey(itm1)) {
                        condFpTree.get(s.subTreeId).put(itm1, s.supCnt);
                    } else {
                        Integer t = condFpTree.get(s.subTreeId).get(itm1);
                        t += s.supCnt;
                        condFpTree.get(s.subTreeId).put(itm1, t);
                    }
                }
            }


        }

        
        
        System.out.println("INFO: All frequent itemsets:");
        for(ItemSet s : freqItemSets) {
            System.out.println(String.format("  %s support count: %d", s.getItemsRepr(), s.supCnt));
        }

        System.out.println("INFO: All association rules:");
        for(ItemSet s : freqItemSets) {
            // enumerate all non-empty proper subset of s
            int binSet = 0;
            for(String itm : s.items) {
                binSet |= (1 << itemsCache.indexOf(itm));
            }
            int b = binSet;
            while(true) {
                b = (b - 1) & binSet;
                if(b == 0) {
                    break;
                }
                ArrayList<String> subsetItems = new ArrayList<>();
                for(int j = 0; j < itemsCache.size(); j++) {
                    if((b & (1 << j)) > 0) {
                        subsetItems.add(itemsCache.get(j));
                    }
                }
                // s.items & subsetItems are both sorted
                // we can always find the subset
                ItemSet subset = null;
                for(ItemSet s1 : freqItemSets) {
                    if(s1.items.equals(subsetItems)) {
                        subset = s1;
                        break;
                    }
                }
                if((double)s.supCnt / subset.supCnt >= minConfThr) {
                    ArrayList<String> complement = (ArrayList<String>)s.items.clone();
                    complement.removeAll(subset.items);
                    ItemSet dummy = new ItemSet(0);
                    dummy.items = complement;
                    System.out.println(String.format("  %s => %s", subset.getItemsRepr(), dummy.getItemsRepr()));
                }
            }
        }
        return true;
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String defaultDataFilePath = "test-data.txt";
        System.out.println(String.format("Please specify the data file path (default - %s):", defaultDataFilePath));
        String dataFilePath = sc.nextLine();
        if(dataFilePath.isEmpty()) {
            dataFilePath = defaultDataFilePath;
        }
        System.out.println(String.format("INFO: Data file path: %s", dataFilePath));

        int defaultMinSupCnt = 2;
        System.out.println(String.format("Please specify the minimum support count (default - %d):", defaultMinSupCnt));
        int minSupCnt;
        try{
            minSupCnt = Integer.parseInt(sc.nextLine());
        } catch(NumberFormatException e){
            minSupCnt = defaultMinSupCnt;
        }
        System.out.println(String.format("INFO: Minimum support count: %d", minSupCnt));

        double defaultMinConfThr = 0.5;
        System.out.println(String.format("Please specify the minimum confidence threshold (default - %f):", defaultMinConfThr));
        double minConfThr;
        try{
            minConfThr = Double.parseDouble(sc.nextLine());
        } catch(NumberFormatException e){
            minConfThr = defaultMinConfThr;
        }
        System.out.println(String.format("INFO: Minimum confidence threshold: %f", minConfThr));

        fpGrowth(dataFilePath, minSupCnt, minConfThr);

        sc.close();
    }
}
